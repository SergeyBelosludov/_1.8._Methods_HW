import java.time.LocalDate;
import java.util.Arrays;

public class main {
    public static void main(String[] args) {

        System.out.println();
        System.out.println("***** Задание 1 *****");
        System.out.println();
//        Реализуйте метод, который получает в качестве параметра год, а затем проверяет,
//        является ли он високосным, и выводит результат в консоль.
//        Эту проверку вы уже реализовывали в задании по условным операторам.
//        Теперь проверку нужно обернуть в метод и использовать год, который приходит в виде параметра.
//        Результат программы выведите в консоль. Если год високосный,
//        то должно быть выведено "номер года — високосный год". Если год не високосный,
//        то, соответственно: "номер года — не високосный год".
//        Подсказку с выполнением задания вы можете найти в шпаргалке урока.
//            Критерии оценки
//          – Метод реализован корректно.
//          – Название метода начинается с глагола, написано в camelCase и описывает действия метода
//          – При изменении значения года программа выводит корректный результат.
//          – В консоль выведены результат программы.

        int year = 2023;
        printAboutYear(year);

        System.out.println();
        System.out.println("***** Задание 2 *****");
        System.out.println();
//        Вспомним задание 2 по условным операторам, где нам необходимо было предложить пользователю
//        облегченную версию приложения.
//        -- Текст прошлого задания:
//               К нам пришли коллеги и сообщили, что нам нужно знать не только операционную систему телефона,
//               но и год его создания: от этого зависит, подойдет ли приложение для телефона
//               или оно просто не установится.
//               Если телефон произведен с 2015 по нынешний год, то приложение будет работать корректно.
//               Если телефон произведен ранее 2015 года, то клиенту нужно посоветовать установить облегченную
//               версию приложения.
//               Ваша задача: написать программу, которая выдает соответствующее сообщение клиенту при наличии
//               двух условий — операционной системы телефона (iOS или Android) и года производства.
//               Если год выпуска ранее 2015 года, то к сообщению об установке нужно добавить информацию об
//               облегченной версии.
//               Например, для iOS оно будет звучать так:
//               «Установите облегченную версию приложения для iOS по ссылке».
//               А для Android так:
//               «Установите облегченную версию приложения для Android по ссылке».
//               При этом для пользователей с телефоном с 2015 года выпуска нужно вывести обычное предложение
//               об установке приложения.
//               Для обозначения года создания используйте переменную clientDeviceYear,
//               где необходимо указать 2015 год.
//               Важно: вложенность больше двух этажей не допускается (условный оператор внутри условного оператора).
//        Напишите метод, куда подаются два параметра: тип операционной системы (ОС) ( 0 — iOS или 1 — Android )
//        и год выпуска устройства.
//        Если устройство старше текущего года, предложите ему установить lite-версию (облегченную версию).
//        Текущий год можно получить таким способом:
//             int currentYear = LocalDate.now().getYear();
//        Или самим задать значение вручную, введя в переменную числовое значение.
//        В результате программа должна выводить в консоль в зависимости от исходных данных, какую версию приложения
//        (обычную или lite) и для какой ОС (Android или iOS) нужно установить пользователю.
//        Подсказку с выполнением задания вы можете найти в шпаргалке урока.
//        Критерии оценки:
//           – Метод написан корректно.
//           – Метод выполняет условие задания.
//           – Результат в консоль выводится согласно всем вводным условиям.

        indicatesInstallOs(0, 2023);

        System.out.println();
        System.out.println("***** Задание 3 *****");
        System.out.println();
//        Возвращаемся к любимой многими задаче на расчет дней доставки банковской карты от банка.
//        -- Текст прошлого задания:
//                Вернемся к делам банковским. У нас хороший банк, поэтому для наших клиентов мы организуем доставку
//                банковских карт на дом с четкой датой доставки. Чтобы известить клиента о том, когда будет
//                доставлена его карта, нам нужно знать расстояние от нашего офиса до адреса доставки.
//                Правила доставки такие:
//                Доставка в пределах 20 км занимает сутки.
//                Доставка в пределах от 20 км до 60 км добавляет еще один день доставки.
//                Доставка в пределах от 60 км до 100 км добавляет еще одни сутки.
//                То есть с каждым следующим интервалом доставки срок увеличивается на 1 день.
//                Напишите программу, которая выдает сообщение в консоль:
//                "Потребуется дней: " + срок доставки
//                Объявите целочисленную переменную deliveryDistance = 95, которая содержит дистанцию до клиента.
//        Наша задача — доработать код, а именно написать метод, который на вход принимает дистанцию и возвращает
//        итоговое количество дней доставки.
//        Критерии оценки:
//          – Метод написан корректно.
//          – Все условия задачи соблюдены.

        int deliveryDistance = 95;
        printAboutDeliveryDays(deliveryDistance);

        System.out.println();
        System.out.println("***** Повышенный уровень. Задание 4 *****");
        System.out.println();
/*
Напишите метод, который получает на вход массив и переставляет все его элементы в обратном порядке.
Подобное задание вы решали в домашнем задании по массивам.
- Текст прошлого задания
        Отойдем от подсчетов.
        В нашей бухгалтерской книге появился баг. Что-то пошло нет так, и Ф.И.О. сотрудников начали отображаться
        в обратную сторону. Т. е. вместо «Иванов Иван Иванович» мы имеем «чивонавИ навИ вонавИ».
        Данные с именами сотрудников хранятся в виде массива символов (char[]).
        Напишите код, который в случае такого бага будет выводить Ф. И. О. сотрудников в корректном виде.
        В качестве данных для массива используйте:
        char[] reverseFullName = { 'n', 'a', 'v', 'I', ' ', 'v', 'o', 'n', 'a', 'v', 'I'};
        В результате в консоль должно быть выведено "Ivanov Ivan".
        **Важно**: не используйте дополнительные массивы для решения этой задачи. Необходимо корректно пройти по
        массиву циклом и распечатать его элементы в правильном порядке.
В метод приходит массив, допустим:
{3, 2, 1, 6, 5}.
Нужно без вспомогательного массива переместить элементы так, чтобы поданный массив стал: {5, 6, 1, 2, 3}.
Рекомендуем написать этот метод без возвращаемого значения. Вы будете приятно удивлены, что даже если мы не вернем
массив, первоначальный массив изменится, когда мы будем модернизировать пришедший в виде параметра массив внутри метода.
Причину такого поведения ссылочных типов (объектов) вы узнаете на следующем уроке или на QA-вебинаре.
 */

        int[] initialArray = {3, 2, 1, 6, 5};
        reversArr(initialArray);

        System.out.println();
        System.out.println("***** Повышенный уровень. Задание 5 *****");
        System.out.println();
        /*
Вернемся к задаче о валидаторе текста из урока по строкам.
- Условие задачи из урока 1.7
        Повышенная сложность. Задание 8
        Дана строка из букв английского алфавита "aabccddefgghiijjkk".
        Нужно найти и напечатать буквы, которые дублируются в строке.
        Обратите внимание, что строка отсортирована, т.е. дубли идут друг за другом.
        В итоге в консоль должен быть выведен результат программы: "acdgijk".
        - Критерии оценки
             – Данные в строке отсортированы корректно.
             – При изменении содержания строки результат программы выполняется.
             – Результат программы выведен в консоль согласно условиям задачи.
Напишите метод, который в виде параметра принимает отсортированную строку.
Например, aabccddefgghiijjkk.
С помощью цикла проверьте, что в строке нет дублей, и выведите в консоль сообщение об этом.
Если дубль найден, нужно прервать поиск по остальным символам и вывести сообщение о присутствии дубля,
причем с указанием, какой именно символ задублирован. Затем сразу же прервать выполнение метода.
Сам метод ничего возвращать не должен (void).
         */

        String withDuplicates = "aabccddefgghiijjkk";
        selectsDuplicates(withDuplicates);


        System.out.println();
        System.out.println("***** Повышенный уровень. Задание 6 *****");
        System.out.println();
        /*
Снова вспоминаем домашнее задание по массивам. В нем была задача, которая требовала высчитать среднюю выплату за день.
Был дан сгенерированный массив из 30 значений от 100 до 200 тысяч, для его генерации допускается использовать метод
из прошлого домашнего задания.
- Текст прошлого задания
        Нам нужно понять, какую в среднем сумму наша компания тратила в течение данных 30 дней.
        Нужно написать программу, которая посчитает среднее значение трат за месяц (то есть сумму всех трат за месяц
        поделить на количество дней), и вывести в консоль результат в формате: «Средняя сумма трат за месяц
        составила … рублей».
        **Важно помнить:** подсчет среднего значения может иметь остаток (то есть быть не целым, а дробным числом).
Нужно сгенерировать массив, подать его в наш метод, а внутри метода подсчитать сумму элементов и вычислить среднее
значение, которое нужно вернуть из метода в виде результата.
Сложность в том, что метод нужно не просто написать, но еще и декомпозировать.
То есть для работы этого метода нужно будет создать еще методы (1 или более), которые его будут обслуживать и
вычислять промежуточные результаты. Среднее значение нужно вычислять в дробном виде, так как результат должен быть
точным.
- **Критерии оценки**
        – Методы декомпозированы корректно.
        – Программа выводит корректный результат при изменении значений массива.
         */
        int[] arr = generateRandomArray();
        double result = countAmount(arr);
        System.out.println("result = " + result);
    }

    // Методы для Задания 1.
    private static boolean isLeapYear(int year) {
        return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
    }

    private static void printLeapYear(int year) {
        System.out.println(year + " year is a leap year");
    }

    private static void printNotLeapYear(int year) {
        System.out.println(year + " year is not a leap year");
    }

    private static void printAboutYear(int year) {
        if (isLeapYear(year)) {
            printLeapYear(year);
        } else {
            printNotLeapYear(year);
        }
    }

    // Методы для Задания 2.
    private static void indicatesInstallOs(int clientOS, int clientDeviceYear) {
        String finalString = printFinalString(clientOS, clientDeviceYear);
        System.out.println(finalString);
    }

    private static String printFinalString(int clientOS, int clientDeviceYear) {
        int currentYear = LocalDate.now().getYear();
        StringBuilder stringBuilder = new StringBuilder();
        if (clientDeviceYear < currentYear) {
            stringBuilder.append("Install the lite version of the app by following the link ");
        } else {
            stringBuilder.append("Install the full version of the app by following the link ");
        }
        if (clientOS == 0) {
            stringBuilder.append(" for iOS");
        } else {
            stringBuilder.append(" for Android");
        }
        return stringBuilder.toString();
    }

// Методы для Задания 3.

    private static void calculateDeliveryDays(int deliveryDistance) {
        if (deliveryDistance <= 20) {
            System.out.println("It will take days: 1");
        } else if (deliveryDistance <= 60) {
            System.out.println("It will take days: 2");
        } else if (deliveryDistance <= 100) {
            System.out.println("It will take days: 3");
        }
    }

    private static void printError(int deliveryDistance) {
        if (deliveryDistance > 100 || deliveryDistance <= 0) {
            System.out.println("Contact customer support");
        }
    }

    private static boolean isDelivery(int deliveryDistance) {
        return deliveryDistance > 0 && deliveryDistance <= 100;
    }

    private static void printAboutDeliveryDays(int deliveryDistance) {
        if (isDelivery(deliveryDistance)) {
            calculateDeliveryDays(deliveryDistance);
        } else {
            printError(deliveryDistance);
        }
    }

    // Методы для: Повышенный уровень. Задание 4
    private static void reversArr(int[] initialArray) {
        int n;
        for (n = initialArray.length - 1; n >= 0; --n) {
            System.out.print(initialArray[n]);
        }
        System.out.println();
    }

    // Методы для: Повышенный уровень. Задание 5
    private static void selectsDuplicates(String withDuplicates) {
        char[] arrayDuplicates = withDuplicates.toCharArray();
        Arrays.sort(arrayDuplicates);
        StringBuilder duplicates = new StringBuilder();
//        boolean
        for (int i = 0; i < arrayDuplicates.length - 1; i++) {
//            for (int j = i + 1; j < arrayDuplicates.length; j++) {
            if (arrayDuplicates[i] == arrayDuplicates[i + 1]) {
                duplicates.append(arrayDuplicates[i]);
                System.out.println("Дублируемый символ - " + arrayDuplicates[i]);
                break;
            }
        }
        if (duplicates.length() == 0) {
            System.out.println("В строке дублей нет");
        }
    }

    // Методы для: Повышенный уровень. Задание 6

    public static int[] generateRandomArray() {
        java.util.Random random = new java.util.Random();
        int[] arr = new int[30];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = random.nextInt(100_000) + 100_000;
        }
        return arr;
    }

    private static double averageSpent(int[] arr) {
        int amount = 0;
        for (int i : arr) {
            amount += i;
        }
        return amount;
    }

    private static int countAmount(int[] arr) {
        double amount = averageSpent(arr);
        double avSpent = amount / (arr.length);
        System.out.println("Средняя сумма трат за месяц составила " + avSpent + " рублей");
        return (int) avSpent;
    }
}